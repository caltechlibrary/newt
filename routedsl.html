<!DOCTYPE html>
<html>
<head>
    <title>Newt -- a new take on the webstack</title>
    <link rel="stylesheet" href="https://caltechlibrary.github.io/css/site.css">
</head>
<body>
<header>
<a href="https://library.caltech.edu"><img src="https://caltechlibrary.github.io/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
	<li><a href="/">Home</a></li>
	<li><a href="./">README</a></li>
	<li><a href="user-manual.html">User Manual</a></li>
	<li><a href="LICENSE">LICENSE</a></li>
	<li><a href="INSTALL.html">INSTALL</a></li>
	<li><a href="about.html">About</a></li>
	<li><a href="https://github.com/rsdoiel/newt">GitHub</a></li>
</ul>
</nav>

<section>
<h1 id="a-routedsl-a-domain-specific-language-describing-routing">A
RouteDSL, a domain specific language describing routing</h1>
<p>How do you describe mapping of one path to another? Many web
frameworks implement the concept of a “route” which is similar to a file
path but may include a placeholder notation which hold values bound to
variable names. The variable names are then avaialble to route handler
functions.</p>
<p>Newt’s route handler capability is fixed. It can perform a mapping
from a request to JSON data API, and optional to Pandoc when the data is
returned from the JSON data API. Aside for validating the varaible
(RouteDSL uses typed varaibles) Newt does not perform additional
processing.</p>
<h2 id="why-create-yet-another-dsl">Why create yet another DSL?</h2>
<p>I surveyed the route descriptions available in several Python and
JavaScript fameworks. There was no concensus. None provided a mechanism
to validate the variables captured int he in-bound request. Since Newt’s
skope is strickly limited this lead me to think about a simple, light
weight markup that would be intuitive for web developers who were
already familiar with template markup like <a
href="https://mustache.github.io/">Mustashe</a> and <a
href="https://handlebarsjs.com/">Handlerbars</a>. What was missing a
type annotation for in-bound requests. Injecting a type annocation for
the request URL pattern mean that the URL composed or the JSON data API
request or Pandoc server request could just be simple handlebars
template strings. This means the is only one added concept for a well
known template notation.</p>
<p>NOTE: This document if focused on discussing the concepts behind
RouteDSL not how to implement it in a specific language.</p>
<h2 id="blogging-urls-a-use-case">Blogging URLs, a use case</h2>
<p>RouteDSL should be able to handle simple mappings such as those seen
in blogs. Blog paths are often predictable. A home page is at
<code>/</code>, a feed of items might be at <code>/feed/</code> and
individual blog posts might be found in a path formed by embedding four
digit year, two digit month, two digit day and a title slug. Let’s first
look at how that would be discribed as a Mustache tempalte –
<code>/blog/{{year}}/{{month}}/{{day}}/{{title-slug}}</code>. This is
pretty easy to read.</p>
<p>How do we know when a path value matches a route? For a literal path
you can simply perform a string comparision but for a path with embedded
variables you need to vet the variables to make sure they make sense. In
effect you need to do a type check. In our simple Mustasche version
though there is no type information. The place holder
<code>{{year}}</code> hold a integer year or maybeone something
completely unrelated. What if we added an annotation about the variables
type? A “year” certainly can be validate. Years are normally four digit
numbers. Likewise month and day could have a simple validation based on
being an integer with two digits allowing for leading zeros. These are
common enough date formats that many languages provide via standard
libraries. Creating types for these types becomes a matter of wrapping
an implementations existing type system.</p>
<pre><code>/blog/{{year Year}}/{{month Month}}/{{day Day}}/{{title-slug String}}</code></pre>
<p>Now we know the type and validation method to apply to the embedded
varaible.</p>
<div class="line-block">path value | is it valid? | year | month | day |
title-slug |<br />
/blog/2023/02/28/my-daily-post | yes | 2023 | 2 | 28 | my-daily-post
|<br />
/blog/2023/02/31/my-daily-post | no | 2023 | 2 | invalid day |
my-daily-post |<br />
/blog/2023/28/02/my-daily-post | no | 2023 | invalid month | 2 |
my-daily-post |</div>
<p>Knowing the type lets the router know that path is not valid and
reject it if it is not without contacting other services.</p>
<p>While the RouteDSL specification is not intended to describe a
cannonical set of types an implementation of a RouteDSL certain would.
It should be easy to implement the type system with one or two functions
per type. I suspect as RotueDSLs are implemented a connanical core set
of type will emerge.</p>
<p>In my prototype implementation of RouteDSL I plan to implement the
following types and validators primitive data types – “Integer”,
“String”, “Real”, “Boolean”, “Date”, “Year”, “Month”, “Day”, “Hour”,
“Minute”, “Second”. The Python project <a href="">IdUtils</a> also
suggests a common set of identifiers used in the Library, Archive and
Museum communities. A subset of these will be implemented for the
prototype of RouteDSL (e.g. “ORCID”, “DOI”, “ROR”).</p>
<p>Here’s an example of what our RouteDSL would enable. I think of these
as a path expression –</p>
<pre><code>`/blog/{{year Year}}/{{month Month}}/{{day Day}}/{{title-slug}}`</code></pre>
<p>A transformed version of the input route could then be described
simply as a handlebar template.</p>
<pre><code>http://localhost:3000/blog?year={{year}}&amp;month={{month}}&amp;day={{day}}&amp;title_slug={{title-slug}}</code></pre>
<p>If the request value matches both form and type of embedded variables
then you have enough information to call a microservice like PostgREST,
Solr or Opensearch.</p>
<h2 id="use-case-representing-filenames-and-extenions-in-a-path">Use
case, representing filenames and extenions in a path</h2>
<p>What if your request URL uses file extensions to indicate the choice
of template to use when rendering with Pandoc? Here’s three examples
where the content might be the same but the format changes (e.g. HTML,
Markdown and plain text).</p>
<pre><code>/blog/2023/02/28/my-daily-post.html
/blog/2023/02/28/my-daily-post.md
/blog/2023/02/28/my-daily-post.txt</code></pre>
<p>In our prior example each embedded variable was contained in one
element of the path. A filename can be thought of as one element or as a
“basename” and “extension”. How can we allow for that use case? In the
use case about the “title-slug” corresponds to the “basename” but the
file extension indicates which template to send to Pandoc server.</p>
<p>Here’s how you might represent that in RouteDSL.</p>
<pre><code>`/blog/{year Year}/{month Month}/{day Day}/{title-slug basename}{ext extname}`</code></pre>
<p>Many implementation languages support parsing path into directory
componentsas well as filename and extension. RouteDSL should be able to
leveraget this. This suggests an algorithmic behavior in our RouteDSL
evaluation.</p>
<p>First RouteDSL should split the path into it’s component, then it
should determine if the component is a literal string or a variable
definition. For each component the variable definition needs to conform
to it’s type. The trailing element in a URL path can also have the types
of “basename” (excluding the file extension), extname (for the file
extension value). In the case where you want to treat both the basename
and extension as a single unit we have the String type shown
previously.</p>
<h2
id="algorithm-for-evaluating-a-path-value-against-a-routedsl-expression">Algorithm
for evaluating a path value against a RouteDSL expression</h2>
<ul>
<li>A RouteDSL expression decode into it’s path components parts
<ul>
<li>zero or more directory names
<ul>
<li>directory name can be a literal</li>
<li>directory name can be a variable definition</li>
</ul></li>
<li>zero or one filename
<ul>
<li>a filename can be a literal</li>
<li>a filename can be a variable expression</li>
</ul></li>
</ul></li>
<li>A path value is split into it’s components
<ul>
<li>zero or more directory names</li>
<li>zero or one filename and extension</li>
</ul></li>
<li>Compare each path value element against each RouteDSL expression
elements
<ul>
<li>if both are literals
<ul>
<li>stop processing if they do not match, return false</li>
</ul></li>
<li>if RouteDSL component is a variable, valid the path value component
against variable type
<ul>
<li>stop of it does not validate, return false</li>
</ul></li>
</ul></li>
<li>If comparison completes without return false we have a match</li>
</ul>
<h2 id="variable-definitions">Variable definitions</h2>
<p>In the use cases we’ve suggested how a variable in a RouteDSL
expression can include a variable name as well as a type annotation to
use to validate the value bould to the variable name. Let’s specify this
in more detail.</p>
<ul>
<li>varaible definition start with two opening curly brace and conclude
with a closing curly brace (i.e. basic Mustache template style
notation)</li>
<li>following the opening curly braces is a variable name which is
formed from a letter and one or more alphanumeric characters or an
underscores or dashes (i.e. what would be a valid attribute name in a
JSON object). E.g. - <code>a</code>, <code>a1</code>,
<code>a_long_variable_name</code>, <code>title-slug</code> are valid
variable names
<ul>
<li><code>""</code>, <code>1a</code>, <code>+1</code>, <code>{}</code>,
<code>()</code>, <code>$foo</code> are not valid variable names</li>
</ul></li>
<li>a variable name is followed by a space and type expression</li>
<li>a type expression starts with a letter and can be followed by one or
more characters excluding a closing curly brace</li>
</ul>
<p>Here’s some example varaible definitions.</p>
<pre><code>{year Year}
{month Month}
{day Day}
{orcid Regexp &#39;[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]&#39;}</code></pre>
<p>These would result in the following type maps expressed in JSON</p>
<pre><code>{
    &quot;year&quot;: &quot;Year&quot;,
    &quot;month&quot;: &quot;Month&quot;,
    &quot;day&quot;: &quot;Day&quot;,
    &quot;orcid&quot;: &quot;Regexp &#39;[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]&#39;&quot;
}</code></pre>
<p>When a request URL is evaluated against the route template’s type it
will return a simple object with variable names mapped to string
versions of the values. This will allow transforming both data API URLs
and calls to Pandoc service via a simple Mustache like template
implementation.</p>
<p>The RouteDSL does not define the supported types only that the
information can be extracted from a RouteDSL expression as a map between
variable names and a type description. It is up to the specific RouteDSL
implementation to define how the type informaiton is interpreted.</p>
<h2 id="variable-decoding">Variable decoding</h2>
<p>If a path value matches a RouteDSL expression then when the variables
and values can be extracted as a map of variable names and values. The
only constraint is that the map be expressable as a valid JSON object.
E.g.</p>
<p>Given the RouteDSL expression</p>
<pre><code>/people/{orcid ORCID}</code></pre>
<p>and the path value</p>
<pre><code>/people/0000-0003-0900-6903</code></pre>
<p>The resulting map would look like this JSON</p>
<pre><code>{
    &quot;orcid&quot;: &quot;0000-0003-0900-6903&quot;
}</code></pre>
<p>Given the RouteDSL expression</p>
<pre><code>/blog/{year Year}/{month Month}/{day Day}/{title-slug basename}{ext extname}</code></pre>
<p>And the path value</p>
<pre><code>/blog/2022/11/07/compiling-pandoc-from-source.html</code></pre>
<p>A RouteDSL implementation should return a map, dictionary or
associative array with the values converted to the type suggested in the
variable’s type definition. The constraint is that the map can be
expressed as a JSON object. E.g.</p>
<pre><code>{
    &quot;year&quot;: 2022,
    &quot;month&quot;: 11,
    &quot;day&quot;: 7,
    &quot;title-slug&quot;: &quot;compiling-pandoc-from-source&quot;,
    &quot;ext&quot;: &quot;.html&quot;
}</code></pre>
<p>In this case our types “Month”, “Day”, “Year” converted the values to
JSON numbers and the rest were left as JSON strings.</p>
<h2 id="reference-materials">Reference materials</h2>
<ul>
<li><a
href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/URLPattern">URLPattern</a>
at MDN</li>
<li><a
href="https://developer.chrome.com/articles/urlpattern/">URLPattern</a>
at Chrome Developer site</li>
<li><a href="https://pythonbasics.org/flask-tutorial-routes/">Flask
Route tutorial</a></li>
<li><a href="https://github.com/tildeio/router.js/">router.js</a></li>
<li><a
href="https://learn.microsoft.com/en-us/azure/application-gateway/url-route-overview#pathbasedrouting-rule">Azure
application gateway routing</a></li>
<li><a href="https://reactrouter.com/en/main/route/route">React
Router</a></li>
<li><a
href="https://nextjs.org/docs/app/building-your-application/routing">Nextjs
routing</a></li>
<li><a
href="https://www.django-rest-framework.org/api-guide/routers/">dJango
routing</a></li>
</ul>
</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2023 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
