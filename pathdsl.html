<!DOCTYPE html>
<html>
<head>
    <title>Newt -- a new take on the webstack</title>
    <link rel="stylesheet" href="/css/site.css">
</head>
<body>
<header>
<a href="http://library.caltech.edu"><img src="/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
	<li><a href="/">Home</a></li>
	<li><a href="./">README</a></li>
	<li><a href="user-manual.html">User Manual</a></li>
	<li><a href="LICENSE">LICENSE</a></li>
	<li><a href="INSTALL.html">INSTALL</a></li>
	<li><a href="about.html">About</a></li>
	<li><a href="https://github.com/rsdoiel/newt">GitHub</a></li>
</ul>
</nav>

<section>
<h1 id="a-pathdsl-a-routing-dsl">A PathDSL, a routing DSL</h1>
<p>How to you describe mapping of one path to another? Many web frame
works implement the concept of a “route” which is similar to a file path
but may include a placeholder notation to easily extract values from the
path and assign them to variables. The is what PathDSL seeks to
address.</p>
<h2 id="why-another-yet-another-routing-dsl">Why another yet another
routing DSL</h2>
<p>Why another DSL for routes? Surveying the route descriptions
available in several Python and JavaScript fameworks each has chosen its
own syntax. There isn’t a concensus nor is there one that appears
entirely suitable. In addition the route syntaxes I’ve seen do not
capture enough information about the variable they are working with to
fully do their job in terms of identifying a path value that matches the
expression or in extracting the variable path elements that will be
exposed to the frameworks.</p>
<p>In a framework setting this isn’t a bad thing as additional
validation or conversion can be applied to the variables described by
the route syntax. The Newt router is very simple and does not have the
luxury of a general purpose programming language that can further vet a
varaible. In addition web applications based around the route concept
often embed varaibles which represent known identifiers or data formats.
It would nice to have not just the variable placement in the path but
also enough “type” information to apply a validator function before
varifying a path value matches the route describe.</p>
<p>One of Newt’s routing features is to take an in bound path and
transform it into a URL suitable to access another micro service like
PostgREST. It would be nice if there was some visual symetry between
describing the route and the template langauge representing the
transformed route. Ulitimately these desired properties moved me to
thinking about PathDSL that would allow easily implementation of path
value matching a route description and a path value that could be easily
transformed with a simple template expression into a new URL.</p>
<p>NOTE: This document if focused on discussing the concepts behind
PathDSL not how to implement it in a specific language.</p>
<h2 id="blogging-urls-a-use-case">Blogging URLs, a use case</h2>
<p>PathDSL should be able to handle simple mappings such as those seen
in blogs. Blog paths are often predictable. A home page is at
<code>/</code>, a feed of items might be at <code>/feed/</code> and
individual blog posts might be found in a path formed by embedding four
digit year, two digit month, two digit day and a title slug –
<code>/blog/{year}/{month}/{day}/{title-slug}</code>. I’ve choosen to
use curly brackets to delimit the variable elements in the path because
handlebars style string formatting is well known.</p>
<p>How do we know when a path value matches a route? For a literal path
you can simply perform a string comparision but for a path with
variables embedded you need to vet the variables for a match. This can
be though of as a validation of the value held by the variable. What if
we annotated the varaible names between the curly braces with some
validatin information? A “year” certainly can be validate if we know
that it conforms to a four digit integer. Month and day could have a
simple validation based on being an integer with two digits allowing for
leading zeros. These are common enough knowns that many languages
provide standard libraries for validating date elements so why not just
create a validation type for this type of data, let’s look at what that
might look like for a blog post path.</p>
<pre><code>/blog/{year Year}/{month Month}/{day Day}/{title-slug String}</code></pre>
<p>Knowing the type (or validation method to use) our we could check a
our PathDSL can evaluate if a given route matches the path value
provided. Let’s look at three path values.</p>
<div class="line-block">path value | is it valid? | year | month | day |
title-slug |<br />
/blog/2023/02/28/my-daily-post | yes | 2023 | 2 | 28 | my-daily-post
|<br />
/blog/2023/02/31/my-daily-post | no | 2023 | 2 | invalid day |
my-daily-post |<br />
/blog/2023/28/02/my-daily-post | no | 2023 | invalid month | 2 |
my-daily-post |</div>
<p>Knowing the type would let the router know that path is not valid
even though it matches the general form we expect in a blog post
path.</p>
<p>While the PathDSL would not implement specific type validation it
would beable to indicate the type of the variable validation to the host
language implementing our router. In principle we could implement
validators for common privitive types like “Integer”, “String”, “Real”,
“Date”, “Year”, “Month”, “Day” but also common types of identifiers like
“ORCID”, “DOI”, “ROR”, “Zipcode”, or “PhoneNumber”. If you added regular
expression you would have a rich type (validation) system for
transforming URLs into another URL.</p>
<p>Here’s an example of what our PathDSL would enable. Path expression
–</p>
<pre><code>`/blog/{year Year}/{month Month}/{day Day}/{title-slug}`</code></pre>
<p>A transformed version of the input route could then be described
simply as a handlebar template.</p>
<pre><code>http://localhost:3000/blog?year={year}&amp;month={month}&amp;day={day}&amp;title_slug={title-slug}</code></pre>
<p>If the value matches both form and types of variables then you have
enough information to call a microservice like PostgREST.</p>
<h2 id="use-case-representing-filenames-and-extenions-in-a-path">Use
case, representing filenames and extenions in a path</h2>
<p>What if you have a service that can return different documents based
on a file extension? How might that be expressed in our PathDSL? Take
these three path values.</p>
<pre><code>/blog/2023/02/28/my-daily-post.html
/blog/2023/02/28/my-daily-post.md
/blog/2023/02/28/my-daily-post.txt</code></pre>
<p>Perhaps you’re using two microservices behind our theoretical router.
These three URL represent the same content but returned in different
formats has as can be rendered by Pandoc server. In this case you want
to be able to extract both the “title-slug” and a file extension. Here’s
how you might represent that in PathDSL.</p>
<pre><code>`/blog/{year Year}/{month Month}/{day Day}/{title-slug basename}{ext extname}`</code></pre>
<p>Many implementation languages support parsing path into directory
components, filename and extension. PathDSL should be able to leveraget
this. This suggests an algorithmic behavior in our PathDSL
evaluation.</p>
<p>First PathDSL should split the path into it’s component, then it
should determine if the component is a literal string or a variable
definition. For each component the variable definition needs to conform
to it’s type. The trailing element in a path can also have the types of
“basename” (excluding the file extension), extname (including the file
extension without the leading period). If you want trailing element to
include both the file name and extension then we can use the “String”
type to describe it.</p>
<h2
id="algorithm-for-evaluating-a-path-value-against-a-pathdsl-expression">Algorithm
for evaluating a path value against a PathDSL expression</h2>
<ul>
<li>A PathDSL expression decode into it’s path components parts
<ul>
<li>zero or more directory names
<ul>
<li>directory name can be a literal</li>
<li>directory name can be a variable definition</li>
</ul></li>
<li>zero or one filename
<ul>
<li>a filename can be a literal</li>
<li>a filename can be a variable expression</li>
</ul></li>
</ul></li>
<li>A path value is split into it’s components
<ul>
<li>zero or more directory names</li>
<li>zero or one filename and extension</li>
</ul></li>
<li>Compare each path value element against each PathDSL expression
elements
<ul>
<li>if both are literals
<ul>
<li>stop processing if they do not match, return false</li>
</ul></li>
<li>if Path DSL component is a variable, valid the path value component
against variable type
<ul>
<li>stop of it does not validate, return false</li>
</ul></li>
</ul></li>
<li>If comparison completes without return false we have a match</li>
</ul>
<h2 id="variable-definitions">Variable definitions</h2>
<p>In the use cases we’ve suggested how a variable in a PathDSL
expression can include a variable name as well as validation
information. Let’s specify this in more detail.</p>
<ul>
<li>varaible definition start with an opening curly brace and conclude
with a closing curly brace</li>
<li>Following the curly brace is a variable name which is formed from a
letter and one or more alphanumeric characters or an underscores or
dashes, e.g.
<ul>
<li><code>a</code>, <code>a1</code>, <code>a_long_variable_name</code>,
<code>title-slug</code> are valid variable names</li>
<li><code>""</code>, <code>1a</code>, <code>+1</code>, <code>{}</code>,
<code>()</code>, <code>$foo</code> are not valid variable names</li>
</ul></li>
<li>a variable name is followed by a space and type expression</li>
<li>a type expression starts with a letter and can be followed by one or
more characters excluding a closing curly brace</li>
</ul>
<p>Here’s some example varaible definitions.</p>
<pre><code>{year Year}
{month Month}
{day Day}
{orcid Regexp &#39;[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]&#39;}</code></pre>
<p>These would result in the following type maps expressed in JSON</p>
<pre><code>{
    &quot;year&quot;: &quot;Year&quot;,
    &quot;month&quot;: &quot;Month&quot;,
    &quot;day&quot;: &quot;Day&quot;,
    &quot;orcid&quot;: &quot;Regexp &#39;[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]\-[0-9][0-9][0-9][0-9]&#39;&quot;
}</code></pre>
<p>The PathDSL does not define the supported types only that the
information can be extracted from a PathDSL expression as a map between
variable names and a type description. It is up to the specific PathDSL
implementation to define how the type informaiton is interpreted.</p>
<h2 id="variable-decoding">Variable decoding</h2>
<p>If a path value matches a PathDSL expression then when the variables
and values can be extracted as a map of variable names and values. The
only constraint is that the map be expressable as a valid JSON object.
E.g.</p>
<p>Given the PathDSL expression</p>
<pre><code>/people/{orcid ORCID}</code></pre>
<p>and the path value</p>
<pre><code>/people/0000-0003-0900-6903</code></pre>
<p>The resulting map would look like this JSON</p>
<pre><code>{
    &quot;orcid&quot;: &quot;0000-0003-0900-6903&quot;
}</code></pre>
<p>Given the PathDSL expression</p>
<pre><code>/blog/{year Year}/{month Month}/{day Day}/{title-slug basename}{ext extname}</code></pre>
<p>And the path value</p>
<pre><code>/blog/2022/11/07/compiling-pandoc-from-source.html</code></pre>
<p>A PathDSL implementation should return a map, dictionary or
associative array with the values converted to the type suggested in the
variable’s type definition. The constraint is that the map can be
expressed as a JSON object. E.g.</p>
<pre><code>{
    &quot;year&quot;: 2022,
    &quot;month&quot;: 11,
    &quot;day&quot;: 7,
    &quot;title-slug&quot;: &quot;compiling-pandoc-from-source&quot;,
    &quot;ext&quot;: &quot;.html&quot;
}</code></pre>
<p>In this case our types “Month”, “Day”, “Year” converted the values to
JSON numbers and the rest were left as JSON strings.</p>
<h2 id="reference-materials">Reference materials</h2>
<ul>
<li><a
href="https://github.com/pillarjs/path-to-regexp">path-to-regexp</a></li>
<li><a
href="https://developer.mozilla.org/en-US/docs/Web/API/URLPattern">URLPattern</a>
at MDN</li>
<li><a
href="https://developer.chrome.com/articles/urlpattern/">URLPattern</a>
at Chrome Developer site</li>
<li><a href="https://pythonbasics.org/flask-tutorial-routes/">Flask
Route tutorial</a></li>
<li><a href="https://github.com/tildeio/router.js/">router.js</a></li>
<li><a
href="https://learn.microsoft.com/en-us/azure/application-gateway/url-route-overview#pathbasedrouting-rule">Azure
application gateway routing</a></li>
<li><a href="https://reactrouter.com/en/main/route/route">React
Router</a></li>
<li><a
href="https://nextjs.org/docs/app/building-your-application/routing">Nextjs
routing</a></li>
<li><a
href="https://www.django-rest-framework.org/api-guide/routers/">dJango
routing</a></li>
</ul>
</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2023 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
