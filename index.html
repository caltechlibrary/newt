<!DOCTYPE html>
<html>
<head>
    <title>Newt -- a new take on the webstack</title>
    <link rel="stylesheet" href="https://caltechlibrary.github.io/css/site.css">
</head>
<body>
<header>
<a href="https://library.caltech.edu"><img src="https://caltechlibrary.github.io/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
	<li><a href="/">Home</a></li>
	<li><a href="./">README</a></li>
	<li><a href="user-manual.html">User Manual</a></li>
	<li><a href="LICENSE">LICENSE</a></li>
	<li><a href="INSTALL.html">INSTALL</a></li>
	<li><a href="about.html">About</a></li>
	<li><a href="https://github.com/rsdoiel/newt">GitHub</a></li>
</ul>
</nav>

<section>
<h1 id="newt-my-new-take-on-the-web-stack">Newt, my new take on the web
stack</h1>
<p>Newt is two things. It is short a “new take” on building web
applications. It is also an experimental microservice for working with
other off the shelf <a
href="https://en.wikipedia.org/wiki/Microservices">microservices</a>.</p>
<p>Currently I am exploring using Newt to integrate <a
href="https://postgresql.org">Postgres</a>, <a
href="https://postgrest.org">PostgREST</a> and <a
href="https://pandoc.org">Pandoc</a>.</p>
<p>The Newt application can be thought of as both a data router and a
light weight static file server.</p>
<p>Newt can route a request to a JSON data API and then optionally send
that result through Pandoc for further processing. Newt runs as a
localhost service only. To use in a production setting it would sit
behind a traditional web server like Apache 2 or NginX.</p>
<h2 id="motivation">Motivation</h2>
<p>My belief is that many web services used by Archives, Libraries and
Museums can benefit from a simplified and consistent back-end. If the
back-end is “easy” then the limited developer resources can be focused
on the front-end. <strong>An improved front-end offers opportunities to
provide a more humane user experience for staff and
patrons.</strong></p>
<h2 id="newts-approach">Newt’s approach</h2>
<p>From front-end to back-end</p>
<ul>
<li>A front end web server (e.g. Apache 2, NginX) can provide access
control where appropriate (e.g. Single Sign on with OAuth2 or
Shibboleth)</li>
<li>Newt provides static file services but more importantly serves as a
data router. I can map a request to a JSON data API, take those results
then send them through Pandoc for transformation.</li>
<li>Postgres+PostgREST is an example of a JSON data API</li>
<li>Pandoc server provides a templating engine to transform data
sources</li>
</ul>
<p>All these can be treated as “off the shelf”. Aside from configuration
they can run as traditional services on most POSIX systems. Your
application is implemented using SQL. It is enhanced by using Pandoc
templates used to turn JSON into HTML (or other desired formats).</p>
<h2 id="beyond-postgrespostgrest">Beyond Postgres+PostgREST</h2>
<p>Newt can talk to any JSON data API as long as it returns its content
in JSON. This means Newt can also route content to Solr or Elasticsearch
before taking the results and sending them through Pandoc. This more
elaborate setup would look like this from front-end to back-end.</p>
<ul>
<li>A front end web server (e.g. Apache 2, NginX) integrated providing
access control where appropriate (e.g. Single Sign on with OAuth2 or
Shibboleth)</li>
<li>Newt URL router (uses a CSV file for defining routes)</li>
<li>Search Engine (e.g. Solr, Opensearch)</li>
<li>Postgres+PostgREST (provides a data source API, is programmed in
SQL)</li>
<li>Pandoc server (provides a templating engine to transform data
sources)</li>
</ul>
<p>Once again the routes define where the requests go (e.g. Solr or
PostgREST). Pandoc templates transform the JSON responses into HTML
result pages.</p>
<p>The main additional work beyond the initial scenario is creating the
Pandoc templates you need to display the results from querying Solr or
Elasticsearch.</p>
<h2 id="exploring-newts-friends">Exploring Newt’s friends</h2>
<ul>
<li>Pandoc</li>
<li>Postgres and PostgREST</li>
</ul>
<h3 id="pandoc">Pandoc</h3>
<p>Pandoc can be thought of as a powerful template engine. It is
familiar to many people who building “static” websites. It is known for
being able to convert many structured text formats from one to another.
The <a href="birds1/">birds 1 demo</a>, a simple bird listing site, is
built using Pandoc with content written Markdown and a list of birds
sighted maintained in a CSV file. Pandoc is used to render both into the
HTML needed to display the website.</p>
<h2 id="demonstrations">Demonstrations</h2>
<p>There are three <a
href="https://github.com/caltechlibrary/newt/tree/main/demos">demos</a>
provided in this repository. They can be generated with a simple Bash
scripts. The bash scripts will generate all the file needed to run the
demos.</p>
<dl>
<dt><a
href="https://github.com/caltechlibrary/newt/blob/main/demos/setup-birds1.bash">Birds
1 Demo</a></dt>
<dd>
Shows a simple use of Pandoc to render a static bird sightings website
</dd>
<dt><a
href="https://github.com/caltechlibrary/newt/blob/main/demos/setup-birds2.bash">Birds
2 Demo</a></dt>
<dd>
Shows a dynamic bird sightings website using Postgres+PostgREST, but
requires JavaScript running in your web browser
</dd>
<dt><a
href="https://github.com/caltechlibrary/newt/blob/main/demos/setup-birds3.bash">Birds
3 Demo</a></dt>
<dd>
Shows a dynamic bird sightings website using Newt with
Postgres+PostgREST and Pandoc
</dd>
</dl>
<p>The goal of the three websites is to show an evolution towards
simplicity for a given website type.</p>
<h3 id="birds-1-demo-pandoc-only">Birds 1 Demo, Pandoc only</h3>
<p>This is a simple static website. It introduces Pandoc and which we
leverage in bird 3 demo. It also is a good tool to rendering static
content with. Static websites are generally simple to generate and
maintain.</p>
<ul>
<li>README.md, demo read me</li>
<li>birds.csv, our list of bird sightings</li>
<li>birds.md, site welcome and description</li>
<li>build.sh, a shell script that uses Pandoc to render site</li>
<li>htdocs, the website document directory</li>
<li>page.tmpl, a Pandoc page template using by build.sh</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Pros</th>
<th style="text-align: left;">Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Pandoc is widely known</td>
<td style="text-align: left;">Updates require changing birds.csv</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pandoc is easily scripted</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h3 id="birds-2-demo-postgres-postgrest">Birds 2 Demo, Postgres +
PostgREST</h3>
<p>Postgres and PostgREST can be combined to provide a dynamic data
source for our birds 2 demo website. In birds 2 demo PostgREST runs on
localhost and we use another web server to presents the static files and
to proxy to PostgREST. The enhancements over birds 1 demo is our list of
birds is held in a Postgres database which is available to our web
browser thanks to proxying to PostgREST. The web browser uses JavaScript
to call back to the JSON data API and using the results to render
content in the web page.</p>
<p>The back-end is written using SQL. This includes setting up access by
PostgREST. The font-end JavaScript is required in the browser to
assemble pages results from our JSON data API is complex. The complexity
is shifted out of the back-end which is using an off the shelf micro
service to the front-end.</p>
<ul>
<li>README.md, demo read me</li>
<li>birds.csv, our sightings data, loaded into SQL database</li>
<li>htdocs, the website document directory</li>
<li>htdocs/sightings.js, JavaScript support is required in the web
browser to render the page and handle updates</li>
<li>postgrest.conf, configuration for PostgREST</li>
<li>setup.sql, SQL setting up data models and JSON data API</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Pros</th>
<th style="text-align: left;">Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Simple back-end, just SQL code</td>
<td style="text-align: left;">JavaScript in the browser is complex</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">You need a static file server</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">You need to know some SQL</td>
</tr>
</tbody>
</table>
<h3 id="birds-3-demo-assembling-responses-with-newt">Birds 3 demo,
assembling responses with Newt</h3>
<p>Managing page assembly browser side is a chore. We can skip the
complex JavaScript browser side if we let Newt do the routing of
requests to PostgREST and then sending those results through Pandoc like
we did in our static site demo. With just SQL and Pandoc templates we
can build a web application.</p>
<p>Newt needs to know how to map the front-end requests to PostgREST so
to do that it reads a CSV file holding data routing instructions. E.g.
turn a request URL into a PostgREST URL and run the results through
Pandoc running as a microservice.</p>
<ul>
<li>README.md, demo read me</li>
<li>birds-routes.csv, CSV holding data routing instructions</li>
<li>birds.csv, CSV holding data to be loaded into our SQL database</li>
<li>birds.yaml, configuration for Newt</li>
<li>htdocs, holds our static content</li>
<li>page.tmpl, Pandoc template for listing birds</li>
<li>postgrest.conf, configuration for PostgREST</li>
<li>setup.sql, SQL setting of data models and JSON data API</li>
</ul>
<p>This is very similar to both demo 1 and 2. Missing is build.sh from
demo 1. We don’t need it since we’re running Pandoc as a microservice.
There is an added configuration file for Newt. The Pandoc template
performs a similar duty as the one used in birds 1 demo. Notice there is
no sightings.js in our htdocs directory. From the web browsers point of
view there is no need to run JavaScript to submit a standard web form to
add a bird sighting.</p>
<p>NOTE: Newt provides our static file service so when developing we
don’t need Apache 2 or NginX. But you do need a front-end web server is
you want to add access control or use in a production setting.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Pros</th>
<th style="text-align: left;">Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Simple back-end, just SQL code</td>
<td style="text-align: left;">Like demo 2 you need to know some SQL</td>
</tr>
<tr class="even">
<td style="text-align: left;">No JavaScript required browser side</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Newt provides the static web server</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="more-about-newt">More about Newt</h2>
<p>Configuring Newt can be done in a YAML file or through the shell’s
environment. A minimum setup requires a pointer to the CSV file
container your route definitions. The environment variable needed is
<code>NEWT_ROUTES</code> in the YAML file the attribute is
<code>newt_routes</code>. If you also wish to have static file service
support then you would set <code>NEWT_HTDOCS</code> in the environment
or <code>newt_htdocs</code> in the YAML configuration file.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In the final demo I’ve divided the tasks through a series of flexible
microservices.</p>
<dl>
<dt>Postgres</dt>
<dd>
provides data storage and defines how our JSON data API works
</dd>
<dt>PostgREST</dt>
<dd>
Turns a Postgres database into a our JSON data API service
</dd>
<dt>Pandoc</dt>
<dd>
Run in server mode is a powerful template engine, it can convert our
JSON data into a web page
</dd>
<dt>Newt</dt>
<dd>
Is a data router and static file server. It translates the web form
submission into JSON before sending requests to PostgREST. Newt takes
the results and sends that through Pandoc. Newt can also service static
files. It could be used to talk to a JSON oriented full text search
engine like Solr, Elasticsearch or Opensearch.
</dd>
<dt>Front-end web server</dt>
<dd>
A front-end web server can provide access control and proxy to any of
our microservices, leverage virtual hosting, etc.
</dd>
</dl>
<p>The “coding” of the back-end is reduced to SQL and Pandoc templates.
You are free to make the front-end as simple or as complex as you like.
The microservices and front-end web server effectively snap together
like LEGO bricks.</p>
</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2023 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
