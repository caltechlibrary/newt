<!DOCTYPE html>
<html lang="en">
<head>
    <title>Newt -- README</title>
    <link rel="stylesheet" href="https://caltechlibrary.github.io/css/site.css">
    <base href="./">
</head>
<body>
<header>
<a href="https://library.caltech.edu"><img src="https://caltechlibrary.github.io/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
	<li><a href="/">Home</a></li>
	<li><a href="./">README</a></li>
	<li><a href="user_manual.html">User Manual</a></li>
	<li><a href="LICENSE">LICENSE</a></li>
	<li><a href="INSTALL.html">INSTALL</a></li>
	<li><a href="about.html">About</a></li>
	<li><a href="search.html">Search</a></li>
	<li><a href="https://github.com/caltechlibrary/newt">GitHub</a></li>
</ul>
</nav>

<section>
<h1 id="newt-project">Newt Project</h1>
<p>Newt is an experimental set of tools for rapid application
development. More specifically Newt can build metadata curation tools.
These types of applications are commonly needed in libraries, archives
and museums (abbr: LAM). Newt makes creating these type of applications
easier.</p>
<p>How does Newt do that? Newt implements a service oriented
architecture to assemble web applications. This allows Newt to do less
while making it easier for you to integrate off the shelf software to
compose your application.</p>
<p>You can think of a web application as a sequence of requests and
responses. In a service oriented architecture we take advantage of that
concept but enhance the model by allowing one web service to make a
request from another. Typically when a web browser contacts your
application one of two things will happen. Your app may know the answer
and hand back the result. With the service oriented architecture your
application has another option. Your application can contact to another
service and use that result to answer the request from the web browser.
Newt makes this easy by providing a data router. Unlike setting up a
proxy relationship in Apache or NGINX or relying on a complicated set of
nested containers Newt provides a pipeline<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.
Newt’s pipeline is expressed in YAML. The last service completed hands
its result to the Newt Router which returns the result to the web
browser.</p>
<p>Why is this important? Much of the “back end” of a web application is
already available as off the shelf software. Here is a short list of
examples.</p>
<ul>
<li>Postgres and PostgREST provides a JSON API for data management</li>
<li>MySQL or MariaDB combined with MySQL REST Service provides a web api
for datat management</li>
<li>Solr provides full text search as a web service</li>
<li>Elasticseach and Opensearch provide a full text search engine as a
web service</li>
<li>ArchiveSpace provides a JSON API web service</li>
<li>InvenioRDM provides a JSON API web service</li>
<li>Cantaloupe IIIF Image server has integration points</li>
</ul>
<p>This is not an exhaustive list. These types of applications can all
be integrated into your application through configuring the connection
in Newt’s YAML file. Newt Router runs the data pipelines.</p>
<p>How do you setup a database as a JSON data source? Newt’s code
generator can lend a hand there. Newt’s code generator understands
Newt’s YAML file and can render the data models in useful ways. The Newt
code generator can render the SQL and configuration for
Postgres+PostgREST. Newt’s code generator can render Mustache templates
too. Between the SQL and Mustache temples you have the basic CRUD-L<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> operations required for managing
data. The off the self software, Newt generator, router and temple
service gives you the core features for building LAM applications.</p>
<p>Newt is a narrowly focused rapid application development toolbox. It
does not support the class of web applications that handle file uploads.
It’s not a replacement for Drupal, WordPress, or Islandora. Newt is for
building applications more in line with ArchivesSpace but with simpler
data models. If you need file upload support you can either build that
as a web service or use another software system.</p>
<p>Newt applications are well suited to interacting with other
applications that provide a JSON API. The JSON web API allows Newt to
treat them as a JSON data source. A JSON data source can easily be run
through a pipeline. Many LAM applications like ArchivesSpace and Invenio
RDM provide JSON API. It is possible to extended those systems by
creating simpler services that can talk to those JSON data sources. Newt
is well suited to this “development at the edges” approach. You would
only need to provide a proxy to those services on localhost. You would
write your Newt YAML file. You might enhance some SQL or Mustache
templates generated by Newt. Then you’d used that proxied approach to
integrate your external services (e.g. ORCID, ROR, CrossRef, DataCite,
Pub Med Central).</p>
<p>A Newt application encourages the following.</p>
<ul>
<li>preference for “off the shelf” over writing new code</li>
<li>modeling your data simply</li>
<li>use a database management system for managing your data</li>
<li>prefer software that can function as a JSON data source</li>
<li>transformation data representations (if needed) using a light weight
web service</li>
<li>code generation where appropriate</li>
</ul>
<p>In 2024 there is allot of off the self software to build on. Newt
provides a few tools to fill in the gaps.</p>
<ul>
<li><code>newtrouter</code> is a stateless web service (a.k.a. micro
service) that routes a web request through a data pipeline built from
other web services</li>
<li><code>newtgenerator</code> is a code generator understands the data
models described in Newt’s YAML configuration file. Newt targets
generating code to setup Postgres and PostgREST or generate Mustache
templates</li>
<li><code>newtmustache</code> is a simple stateless template engine
inspired by Pandoc server that supports the Mustache template
language</li>
</ul>
<p>Newt’s 2nd prototype is being tested building applications based
on</p>
<ul>
<li><a href="https://postgres.org">Postgres</a>, data management</li>
<li><a href="https://postgrest.org">PostgREST</a>, a service that turns
Postgres into a JSON API</li>
</ul>
<p>The Newt YAML ties this together expressing</p>
<ul>
<li>applications (run time information for Newt Router and Newt
Mustache)</li>
<li>models (descriptions of data as you would provided in a web
form)</li>
<li>routes (web requests differentiated by a HTTP method and URL path
that trigger processing in a data pipeline)</li>
<li>templates (pairs a request with a template to transform a JSON into
some other format such as an HTML document)</li>
</ul>
<h2 id="what-type-of-applications-are-supported-by-newt">What type of
applications are supported by Newt?</h2>
<p>Most LAM applications are focused on managing and curating some sort
of metadata records. This is the primary target of Newt. This might be
as simple as a controlled vocabulary or as complex as an archival or
repository metadata record.</p>
<h2 id="motivation">Motivation</h2>
<p>Over the last several decades web applications became very complex.
This complexity is expensive in terms of reliability, enhancement, bug
fixes and software sustainability.</p>
<blockquote>
<p>A brief historic detour to set context</p>
</blockquote>
<p>Databases have been used to generate web pages since the early web.
Databases are well suited to managing data. When the web became dynamic,
databases continued to be use for data persistence. By 1993 the web as
an application platform was born<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a> and with it a good
platform for providing useful organizational and institutional
software.</p>
<p>By the mid 1990s the Open Source databases like MySQL and Postgres
were popular choices for building web applications. It is important to
note neither MySQL or Postgres spoke HTTP<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. To
solve this problem many people wrote software in languages like Perl,
PHP and Python that ran inside the popular Apache web server. It was a
pain to setup but once setup relatively easy to build things that relied
on databases. This led the web to explode with bespoke systems. This in
the late 1990s and the early 2000s led to the practice of “mashing up”
sites (i.e. content reuse). As “mashing up” became the rage, bespoke
systems took advantage of content reuse too. <a
href="https://en.wikipedia.org/wiki/Yahoo!_Pipes">Yahoo Pipes</a> was a
very interesting expression of the “mashup culture”<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.
Yahoo Pipes inspired Newt’s data pipelines. Eventual the bespoke systems
gave way to common use cases<a href="#fn6" class="footnote-ref"
id="fnref6" role="doc-noteref"><sup>6</sup></a>. A good example of a
common use case is Apache’s <a href="https://solr.apache.org">Solr</a>
search engine. Another example is how bespoke content management systems
gave way to <a href="https://drupal.org">Drupal</a> and <a
href="https://wordpress.org">WordPress</a>.</p>
<blockquote>
<p>fast forward to 2024, context set</p>
</blockquote>
<p>Much of the back end of web applications can largely be assemble from
off the shelf software. Middleware however remains complex. I believe
this to be a by product of inertia in software development practices and
the assumption that what is good for “Google Scale” is good for
everyone.</p>
<p>I think a radical simplification is due. Newt in part is intended to
spark that conversation. My observation is most software doesn’t need to
scale large. Even in the research and LAM communities we don’t routinely
write software that scales as large as <a
href="https://zenodo.org/">Zenodo</a>. We don’t typically support tens
of thousands of simultaneous users. If you accept that premise then we
can focus our efforts around orchestrating off the shelf components and
put our remaining development efforts into improving the human
experience of using our software. A better human experience is an
intended side effect of Newt.</p>
<blockquote>
<p>OK, a little more context</p>
</blockquote>
<p>Back in the day whether we were writing in PHP, Python or Perl we
were creating middleware. Even Drupal and WordPress are really
middleware. Middleware sits between a data source (e.g. a database) and
the web server (e.g. Apache 2, NGINX). It might be run inside Apache 2
or proxied loke with NGINX. It’s still middleware.</p>
<p>A big key to simplification is narrowing the focus of our middleware.
When our middleware has to implement everything it becomes very complex.
Look at Drupal and WordPress. They implement data modeling, data
management, user accounts, access management, data transformation. What
if middleware was narrowly focus? Conceptually simpler? Did one or two
things really well?. The approach starts to sound familiar. It is the
old Unix philosophy of writing a single tool that does one thing really
well and can be chained together to form a data processing pipeline. If
you step back and look at the web today that is what happening. A
catalog system imports data from trusted sources. Creating a repository
record might start by pulling in data from CrossRef or ORCID. What if
doing that was as easy as using Unix pipes? I think it can using a
little YAML notation.</p>
<p>Here is a description of one implementation of that idea.</p>
<ol type="1">
<li>Apache 2 with Shibboleth provides access control and helps up
communicate with a web browser (e.g. SSL support in the public URL)</li>
<li>Apache 2 proxies to a Newt Router. Newt Router either maps the
request to a data pipeline or provides static content</li>
<li>The data pipeline performs our processing. It can include any number
of web services running on localhost. Which services depend on what we
want to do. If we’re managing data then Postgres+PostgREST is a good
choice. The pipeline first stage might start there. Eventually we’ll
want to turn that JSON into HTML so Newt Mustache provides a reliable
means of doing that.</li>
</ol>
<p>This example is pretty generalized. We could mix and match database
with a JSON API or search engines. It can be easy because we can map
requests to the right pipeline. In effect “mashing up” our local
services to provide the data management and content we need for our
application.</p>
<h2 id="working-with-off-the-shelf-deliverables">Working with off the
shelf deliverables</h2>
<p>Take the following as a for instance.</p>
<ul>
<li>(data management) Postgres combined with PostgREST gives you an out
of the box JSON API for managing data</li>
<li>(full text search) Solr gives you a powerful, friendly, JSON API for
search and discovery</li>
<li>(access control) Apache 2 or NGINX combined with Shibboleth for
access control and communicating with the web browser</li>
<li>(rich client) Web browsers now provide a rich software platform in
their own right</li>
</ul>
<p>With the above list we can build capable applications relying on the
sophisticated features of our web browsers.</p>
<h2 id="hidden-costs-without-the-missing-bits">Hidden costs without the
missing bits</h2>
<p>The problem with my off the shelf list so far is that it forces us to
rely on JavaScript (or WASM module) running in the web browser to use
the JSON API or the search engine that renders JSON results. It sounds
like it should be easier because you are not writing anything that runs
server side. In practice this is a horrible idea<a href="#fn7"
class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>.</p>
<p>What we should do is use Newt to tie those JSON services together,
render the results using a template engine web service and hand HTML
back to the web browser. Newt Router provides a means to tie the
services together, Newt Mustache provides a template engine as web
service. The Newt Router can also serve out our static content that
might be included in the HTML results created by a Mustache template.
Newt provides the missing bits so we don’t need to send JavaScript down
the virtual wire. This approach uses consume less bandwidth, fewer
network accesses and less computations cycles on our device. The web
browser knows how to quickly display HTML and CSS, a Newt application
can provide those easily. It’s a big step forward without writing much
code. Maybe without writing any code if Newt’s code generator does a
sufficient job for your needs.</p>
<h3 id="a-newt-baseline">A Newt baseline</h3>
<p>Web services talk to other web services all the time. This isn’t new.
It isn’t exotic it. LAM systems often do this too. Can we do this on a
small scale too?</p>
<ul>
<li>Can we align access control with our front end web server?</li>
<li>Can we insist our database management system provides flexible JSON
API?</li>
<li>Can we treat the output of one web service as the input for the
next?</li>
<li>Can we aggregate these into a data pipelines?</li>
<li>Will that be enough to define a web application?</li>
</ul>
<p>In 2024 for metadata curation apps I think the answer is “yes we
can”. Here’s an example.</p>
<ul>
<li>Apache2 (or NGINX) as a front end web server responsible for
controlling access</li>
<li>Newt Router receives request from Apache2, routes it appropriately
to our database JSON API, takes the result and run that through a
template engine web service</li>
<li>Newt Mustache provides the template engine as web service</li>
<li>Postgres+PostgREST provide the database with JSON API</li>
</ul>
<p>Newt’s code generator is used to create the SQL to setup our Postgres
database, a PostgREST configuration file and a set of Mustache
templates.</p>
<h2 id="what-comes-with-the-newt-project">What comes with the Newt
Project?</h2>
<p>The primary tools are.</p>
<ul>
<li><a href="newtrouter.1.html">newtrouter</a> a <a
href="https://en.wikipedia.org/wiki/microservices">web service</a>
designed for working with other “off the shelf” web services. It
functions both as a router and as a static file server. It does this by
routing your request through a YAML defined pipeline and returning the
results. Typically this will be a JSON data source and running that
output through a template engine like Newt Mustache.</li>
<li><a href="newtgenerator.1.html">newtgenerator</a> is a command line
program that reads the Newt YAML file and generates SQL and templates
used to build your application. Currently the generator targets SQL for
use with Postgres+PostgREST. The template language being targeted is
Mustache.</li>
<li><a href="newmustache.1.html">newtmustache</a> implements a simple
lightweight template engine supporting <a
href="https://mustache.github.io/">Mustache</a> templates. Mustache
template language is well support by a wide variety of programming
languages include Python, PHP, and JavaScript.</li>
</ul>
<p>Some additional tools are also provided. See the <a
href="user_manual.html">user manual</a> for details.</p>
<h2 id="where-is-my-development-time-going-to-be-spent">Where is my
development time going to be spent?</h2>
<p>The developer writes YAML to generate the back end data management
and templates to render web pages for your application. You can enhance
the generated code further if you want. I suspect that you’ll spend most
of your time improving the human experience of your application through
improving the HTML markup in the templates, writing some CSS and perhaps
enhancing behavior with the JavaScript run in the web browser. If you
need to enhance the back end you work in SQL. If you simply need to
improve the rendering of your database results then you are working with
Mustache templates.</p>
<h2
id="what-about-security-integration-with-single-sign-on-or-other-websites-or-services">What
about security, integration with single sign-on or other websites or
services?</h2>
<p>The <code>newtrouter</code> is a simple web service providing data
routing based on its YAML configuration. It’s a team player. In a
production setting it should be used behind a front end web server like
Apache 2 or NGINX. That latter can be configured to support single
sign-on systems like Shibboleth<a href="#fn8" class="footnote-ref"
id="fnref8" role="doc-noteref"><sup>8</sup></a>. The front end web
service controls access and handles securing the connection with the web
browser. The front end web service proxies to the Newt router. Newt
router receives requests and runs the data pipelines on localhost. The
data pipelines can be composed of off the shelf software like
Postgres+PostgREST, Solr and template engine to turn your JSON into a
web page. Having a clear division of responsibilities helps in securing
your web application. Since Newt router only knows how to talk to
services on localhost you can keep it contained and prevent it from
being used for nefarious actions off system. Like Newt router Newt
Mustache is constrained to localhost for similar reasons.</p>
<p>Limiting Newt web service applications to localhost keeps them
simple. Doing the minimum limits the attack surface for those who want
to do mischief. Neither <code>newtrouter</code> or
<code>newtmustache</code> write to disk or require secrets. They only
communicate via localhost using HTTP protocol.</p>
<h3 id="what-about-scaling">What about “scaling”?</h3>
<p><code>newtrouter</code> is just a router. Aside from reading
configuration at start up it doesn’t maintain state.
<code>newtmustache</code> functions the same way, read in the
configuration and just run. By assigning different ports you can also
run many instances of them. This makes it possible to run them in
parallel, behind load balancer or even through proxying spread them
across many machines. The instances don’t share data or coordinate. They
start up wait for a request and providing an answer.</p>
<p>So what does this all mean? In principle a Newt based applications
can scale big as the slowest element of your pipeline service.</p>
<h3 id="anatomy-of-a-newt-based-web-application">Anatomy of a Newt based
web application</h3>
<p>Newt application development is friendly to version control systems
(e.g. Git). It consists of a Newt configuration file, along with
generated SQL files, HTML templates and any static web assets you’ve
added. A typical disk layout of a Newt project could look like this-</p>
<ul>
<li><code>/</code> project folder
<ul>
<li><code>htdocs</code> this directory holds your static content needed
by your web application</li>
<li><code>*.sql</code> these are the SQL files used by your application
to define your models and behaviors in Postgres</li>
<li><code>templates</code> a template holding your template pages</li>
<li><code>app.yaml</code> would holds the configuration of our Newt
tools</li>
<li><code>CITATION.cff</code> or <code>codemeta.json</code> for project
metadata</li>
</ul></li>
</ul>
<blockquote>
<p>Newt, a type of salamander, doesn’t seek attention. It does its own
thing. You only notice it if you look carefully.</p>
</blockquote>
<h2 id="about-the-newt-source-repository">About the Newt source
repository</h2>
<p>Newt is a project of Caltech Library’s Digital Library Development
group. It is hosted on GitHub at <a
href="https://github.com/caltechlibrary/newt"
class="uri">https://github.com/caltechlibrary/newt</a>. If you have
questions, problems or concerns regarding Newt you can use GitHub issue
tracker to communicate with the development team. It is located at <a
href="https://github.com/caltechlibrary/newt/issues"
class="uri">https://github.com/caltechlibrary/newt/issues</a>.</p>
<h2 id="getting-help">Getting help</h2>
<p><strong>The Newt Project is an experiment!!</strong>. The source code
for the project is supplied “as is”. Newt is most likely broken. At a
stretch it could be considered a working prototype. You should not use
it for production systems. However if you’d like to ask a question or
have something you’d like to contribute please feel free to file a
GitHub issue, see <a
href="https://github.com/caltechlibrary/newt/issues"
class="uri">https://github.com/caltechlibrary/newt/issues</a>. Just keep
in mind it remains an <strong>experiment</strong> as of February
2024.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>A data pipeline is formed by taking the results from one
web service and using it as the input to another web service. It is the
web equivalent of Unix pipes. Prior art: <a
href="https://en.wikipedia.org/wiki/Yahoo!_Pipes">Yahoo! Pipes</a><a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>CRUD-L, acronym meaning, “Create, Read, Update, Delete
and List”. These are the basic actions used to manage metadata or
objects.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Web applications proceeded to eat all the venerable
green screen systems they could find. Eventually they and their
corporate sponsors invented the surveillance economy we have today.
Sometimes “good ideas” have terrible consequences. Making it easier to
produce custom web applications should always be done keeping in mind
the necessity for humane and inclusive use. Newt can be both part of a
solution but also be used to exacerbate human problems. Develop with
consideration for others.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>HTTP being the protocol the communicates with.
Essentially at the time RDBMS spoke a dialect of SQL as the unifying
language. The web of the time understood HTML and to a certain degree
XML. By 2000 people were looking for something simpler than XML to move
structured data about. <a
href="https://en.wikipedia.org/wiki/JSON">JSON</a> quickly became the
answer.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The basic concept was to make it easy to work with “data
feeds” and combined them into a useful human friendly web pages. It even
included a visual programming language to make it friendly to the
non-programmer crowd.<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>If a use case is solved reliably enough it becomes “off
the shelf” software.<a href="#fnref6" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>See <a
href="https://infrequently.org/2024/01/performance-inequality-gap-2024/"
class="uri">https://infrequently.org/2024/01/performance-inequality-gap-2024/</a>
for a nice discussion of the problem.<a href="#fnref7"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Shibboleth is a common single sign-on platform in
research libraries, universities and colleges.<a href="#fnref8"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2023-2024 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
