<!DOCTYPE html>
<html>
<head>
    <title>Newt -- a new take on the webstack</title>
    <link rel="stylesheet" href="https://caltechlibrary.github.io/css/site.css">
</head>
<body>
<header>
<a href="https://library.caltech.edu"><img src="https://caltechlibrary.github.io/assets/liblogo.gif" alt="Caltech Library logo"></a>
</header>
<nav>
<ul>
	<li><a href="/">Home</a></li>
	<li><a href="./">README</a></li>
	<li><a href="user-manual.html">User Manual</a></li>
	<li><a href="LICENSE">LICENSE</a></li>
	<li><a href="INSTALL.html">INSTALL</a></li>
	<li><a href="about.html">About</a></li>
	<li><a href="https://github.com/caltechlibrary/newt">GitHub</a></li>
</ul>
</nav>

<section>
<h1 id="newt">Newt</h1>
<p>Newt project is a collection of tools providing a rapid web
application development platform for libraries, archives and museums.
The collection of commands focuses on using “off the shelf” micro
services combined with a web application composition via a YAML file.
Newt provides the following commands.</p>
<ul>
<li><a href="newt.1.html">newt</a> is an experimental <a
href="https://en.wikipedia.org/wiki/microservices">micro service</a>
designed for working with other “off the shelf” micro services. The
primary purpose is to function as a localhost data router between a data
source and rendering engine. It can also function as a static file
server when development an application</li>
<li><a href="newmustache.1.html">newtmustache</a> is a extremely light
weigth <a href="https://mustache.github.io/">Mustache</a> template
rendering engine inspired by Pandoc server</li>
<li><a href="newtpg.1.html">newtpg</a> is a command line program
designed to generate SQL used bootstrap a JSON API built with PostgREST
and Postgres. Combined <code>newt</code> and <code>newtpg</code> saves
you from building yet another middleware micro service</li>
<li><strong>newtform</strong> (planned but not prototyped) is a web form
generator mathcing the SQL generated for the JSON API</li>
</ul>
<h2 id="why-rapid-development-tools-why-newt">Why rapid development
tools? Why Newt?</h2>
<p>The promise of modern <a
href="https://en.wikipedia.org/wiki/Rapid_application_development"
title="Rapid Application Development">RAD</a> tools is a faster
development cycle delivering a minimal viable application sooner. The
RAD system accomplishes this by code generation taking a splecification
(a.k. configuration file) and rendering the code described. The system
eases development by providing either a simple highlevel configuration
language or a GUI that generated the application code. Often a RAD
system will include GUI building tools as well along with a means of
hooking up the GUI elements to specific actions. In the past these
systems tended to be propriary and often required developer
specialization to use it.</p>
<p>Newt is a lightweight set of RAD tools. They all use the same
configuration langauge, <a
href="https://en.wikipedia.org/wiki/YAML">YAML</a>. Why YAML? Must
developers and even some none developers already know it. The Newt
specific aspects of YAML are the data structures represented as YAML
used by Newt’s commands. Newt doesn’t have a GUI and doesn’t provide
layout tools. The reason if there is lots of software that already does
that for web development. Instead Newt focuses on composing the
conversation between “office the shelf” micro services and static file
assets that result in a “web application”. As a result Newt is very
narrowly focused. It provides a simple data router that can sit behind a
traditional front end web server. Typically this is a JSON data source
such as that provided by Postgres+PostgREST. It includes a lightweight
Mustache template engine that accepts a JSON structure and template
rendering the result. It include a SQL code generator for creating JSON
API using Postgres and PostgREST. It will include a simple tool for
processing the Newt YAML into web forms suitable for including along
with your static assets of your application. Finally Newt is focus in
the application domain of metadata curation for libraries, archives and
museums.</p>
<p>If successful then Newt will assist technically inclined library
staff or librarians in standing simple web applications for metadata
curation.</p>
<h2 id="where-is-development-time-spent">Where is development time
spent?</h2>
<p>With Newt your development time is focused on three areas.</p>
<ol type="1">
<li>Modeling your data in YAML and using that to generate SQL and HTML 5
web forms</li>
<li>Rendering content coming from JSON API using simple templates
engines (e.g. Pandoc or Mustache templates)</li>
<li>Enhancing the user expereience browser side using HTML5, CSS and if
needed JavaScript (a.k.a. traditional front end development)</li>
</ol>
<p>Newt achieves this division of responsibities. Newt’s YAML file is
responsible for describing the data models used by your application and
for defining the specific routes used to access your data pipeline. Your
data pipeline is a small set of micro services. In Newt’s protype I’ve
used Postgres and PostgREST to provide a JSON data source and Pandoc
running in server mode for a template rendering engine. The generative
tools that come with Newt provide the means to render the SQL needed to
setup Postgres and PostgREST as well as generating HTML/Markdown for
your web forms interacting with the JSON API data source.</p>
<h2 id="example-steps-to-demonstrate-building-with-newt">Example steps
to demonstrate building with Newt</h2>
<p>The following example describes using PostgREST+Postgres to provide a
JSON API, Pandoc server as your render engine and Newt to serve static
content and route requests to the JSON API and render engine.</p>
<ol type="1">
<li>Create a directory/folder for your project and change into that
directory (setup version control if desired)</li>
<li>Create a Newt configuration file describing the models and routes
your application will need</li>
<li>Use <code>newtpg</code> and the Newt configuration file to generate
SQL to bootstrap your PostgREST+Postgres JSON service</li>
<li>Use <code>newtform</code> to render HTML/Markdown of your
applications’ web forms</li>
</ol>
<p>At this point you should have a skeleton of your application working.
The following are iterative steps you use to refine your
application.</p>
<ol type="1">
<li>Add/update your initial SQL data models and test inside Postgres
(psql works nicely for this)</li>
<li>Add/update the routes in the routes section of the YAML
configuration file if needed</li>
<li>Add/update any Pandoc templates, HTML, CSS and JavaScript as needed
for your application</li>
<li>(re)start PostgREST and <code>newt</code> then test with your web
browser</li>
</ol>
<p>These steps repeat and are you spend most of your application
development time. Notice that each of the steps are focused on a
specific area of your application. Step one, improving your data
modeling and data management. Step two refining the selection of URLs
your application responds to. Step three Is were we start front end
development by taking the JSON data and rendering it into HTML. It is
here where you can also augment the HTML produced by the template engine
to do more browser side. The least step refreshes your development view
of your application by reloading the JSON API and data router. This is
easily done via a shell script.</p>
<h2
id="what-about-security-single-sign-on-integration-with-websites-or-services">What
about security, single sign-on, integration with websites or
services?</h2>
<p>The <code>newt</code> command is a simple micro service providing
data routing based on its configuration at startup. It’s a team player.
At many universities, colleges, research libraries, archives and museums
there is an existing single sign-on mechanism like Shibboleth running
along with Apache 2 or NginX web servers. Newt would run behind those
services via reverse proxy. Newt itself doesn’t know about users, it
knows about routing requests. Newt after reading the configuration file
doesn’t maintain state. While the log output may contain identifiable
information (e.g. IP address of request) or the JSON data source could
contain sensitive information Newt doesn’t retaining it. It just routes
the data and gets out of the way.</p>
<p>A typical <code>newt</code> production setup might look like this</p>
<ol type="1">
<li>NginX with Shibboleth controls access to web site resources and
where appropriate proxies to <code>newt</code></li>
<li><code>newt</code> responds to requests and maps those to a data
source (e.g. PostgREST+Postgres JSON API) and gets back a response</li>
<li><code>newt</code> can take a data source response and send it to a
render engine (e.g. Pandoc in server mode or
<code>newtmustache</code>)</li>
<li>`newt’ assembled result is handed back to the NginX web server to
pass onto the requesting web browser</li>
</ol>
<p>In the example securing your application can happen both at the NginX
level (e.g. requiring single sign-on) and at the JSON API level via
Postgres’s management of PostgREST responses. NginX can also be used to
proxy external resources you may wish Newt to route to.</p>
<p>Newt tries to do as little as possible while still providing data
routing and static content services. This reduces the attack surface.
Newts log output is written to standard out and standard error and not
directly to disk to avoid the problem of high traffic logging filling up
your disk drive. Logging can easily be captured by your servers logging
system (e.g. systemd and it’s log handler). Newt is configured through
the environment so does not require storing secrets in the configuration
file. Newt only reads the configuration at startup and can not write it
back to disk. In fact Newt can’t write to disk at all. Newt focuses on
data routing at the web application level only. It has a limited two
stage pipeline for requests processing. For any given route defined in
Newt’s configuration it can contact a data source
(e.g. PostgREST+Postgres JSON API) and optionally send the result
through a rendering service (i.e. Pandoc running in server mode) before
handing that result back to the requestor. Newt only knows how to speak
http and can only communicate via localhost so can’t access outside
systems with you proxying to them. Newt only listens for routes defined
at startup or derived from a designated htdocs directory.</p>
<p>Keeping Newt simple minimizes the attack surface and keeps Newt a
team player in your micro service based applications.</p>
<h3 id="what-about-scaling">What about “scaling”?</h3>
<p>Newt is just a data router. You can safely run many Newt instances in
parallel as needed. They can run them on the same machine or separate
machines. The instances don’t share data or coordinate. They just read
their configuration files when they start up and route data
accordingly.</p>
<p>A typical Newt stack of PostgREST+Postgres and Pandoc server also can
scale up. You can run as many instances of Pandoc server or PostgREST as
you need. You can spread them across machines. They are both stateless
systems like Newt. A Postgres database provides consistency and can be
configured in a high availability cluster. Postgres scales.</p>
<p>When I created Newt I was interested in small scale applications. I
created it as a simple stateless micro service. Because it is a simple
stateless micro service can scales as wide as you like. It scales in the
same way as Pandoc server or PostgREST.</p>
<h3 id="annatomy-of-a-newt-based-web-application">Annatomy of a Newt
based web application</h3>
<p>Newt application development is friendly to version control systems
(e.g. Git). It consists of a Newt configuration file, SQL files, HTML
templates and any static web assets you need. A typical disk layout of a
Newt project could look like this-</p>
<ul>
<li><code>/</code> project folder
<ul>
<li><code>htdocs</code> this directory holds your static content needed
by your web application</li>
<li><code>*.sql</code> these are the SQL files used by your application
to define your models and behaviors in Postgres</li>
<li><code>templates</code> this directory holds your Pandoc or Mustache
templates</li>
<li><code>tests</code> this directory holds your tests of your data
model</li>
<li><code>application.yaml</code> would hold the a Newt configuration
file (this is an example name for the configuration file)</li>
</ul></li>
</ul>
<p>Data flow and dividing responsibilities in the Newt stack</p>
<ul>
<li>front end web server controls access, proxies to Newt</li>
<li>Newt receives requests and maps them to a static resource or a data
source
<ul>
<li>A data source could be a JSON API (e.g. PostgREST+Postgres, Solr,
Elasticsearch, Opensearch) accessed via http over localhost</li>
</ul></li>
<li>Newt receives a response from a data source and can send the results
to Pandoc server</li>
<li>Newt hands back a result to your front end web server</li>
</ul>
<h2 id="origin-story">Origin story</h2>
<p>Newt came about when I realized that all I needed was a data router
that could map a web browser request to the JSON API provided by
PostgREST+Postgres and Pandoc running as a service. That setup could
replace most of the applications I’d written for the last decade or two.
It would fit most of the small web applications I had previously built
in PHP or Python for my library. Generalizing the concept of simple data
router for a data source and render engine also meant I had an easy
integration point for most the institutional software we currently run
in our library. So I wrote a data router to do just that.</p>
<p>I demonstrated the Newt concept to my colleagues with a prototype.
The prototype talked to a JSON API provided by PostgREST+Postgres and
used Pandoc running in server mode for a rendering engine. I got some
polite supportive comments. No one was particularly excited by it. I
demonstrated a prototype Newt at a my local SoCal Code4Lib group. There
people were excited by PostgREST and Postgres and not so excited about
data routing. This was discouraging. I thought I was barking up the
wrong tree. Eventually I realized the ambivalence of the router was a
type of success. Newt isn’t exciting. Newt should never be exciting. It
just routes data! You configure it and forget it. It just runs.</p>
<p>The important take away was I had failed to appreciate how Newt
successfully shifted the discussion from programming language
frameworks, package management and build systems to to modeling data in
SQL and using simpler HTML5, CSS and JavaScript for display.</p>
<blockquote>
<p>Newt, a type of salamander, doesn’t seek attention. It does its own
thing. You only notice a salamander if you look carefully.</p>
</blockquote>
<h2 id="system-design-choices">System design choices</h2>
<p>Demonstrating the “Newt stack” has resulted in questions. Here’s the
big four questions.</p>
<ol type="1">
<li>Why SQL? Why build your data models with SQL?</li>
<li>Pandoc as rendering engine, why?</li>
<li>Why YAML for configuration?</li>
<li>How do I handle file uploads?</li>
</ol>
<p>My answer to the first question: I think knowing at least some SQL is
unavoidable as a web developer. While many have adopted an ORM<a
href="ORM,%20object%20relational%20mapper.%20An%20ORM%20maps%20programs%20objects%20to%20a%20SQL%20syntax.%20With%20the%20advent%20of%20JSON%20columns%20in%20SQL%20tables%20this%20is%20rearly%20a%20problem%20anymore.%20Just%20focus%20on%20SQL.">1</a>
to generate the SQL to render models and manage data the resulting SQL
is often far from ideal. This is inspite of the fact that the ORM
concept is decades old. The problem I worry about with ORM (yes, I’ve
use them) isn’t inefficiency. The real problem is the ORM obscures the
data model and that discourages data re-use. The vast majority of web
applications run in institutional settings use SQL databases
(e.g. MySQL, Postgres, Oracle, SQLite3). Embracing SQL gives you power
to extend those systems and even integrte them. In 2024 SQL remains the
common language to manage data in a database. That’s true even have a
half century of existence. Even for non-relational data this has become
true<a
href="I&#39;ve%20heard%20of%20people%20querying%20S3%20buckets%20using%20a%20SQL%20SELECT%20statement%20and%20used%20utilities%20in%20the%20shell%20to%20do%20the%20same%20with%20text%20files.">2</a>.
SQL may look ugly or quirky but it definately has legs and plans to
stick around for a very long time. Let’s embrace it!</p>
<p>You may protest, “but some people really hate writing SQL!” Newt does
provide a tool to address this. Newt provides <code>newtpg</code> that
can take a data model described in the Newt configuration file and
render SQL suitable for standanding up and managing data in Postgres and
PostgREST. Another tool, <code>newtform</code> planed for development,
will render the same model to HTML 5 and JavaScript so you can keep your
model paired between the JSON API that manages the data and your
brower’s web form for doing data entry. in YAML that can be used to
generate Postgres SQL as well as simple HTML 5 web forms. Of course Newt
just provides a tool, you don’t have to use it and you’re welcome to
write SQL and your web forms from scratch.</p>
<p>The second question, why run Pandoc server to render things? Pandoc
is good at transforming structured text. JSON is structured text and
Pandoc can easily turn that into HTML. It is also ready to go in the
spirit of using “off the shelf” micro services. In the data science and
library circles I travel I’ve seen a huge adoption of Pandoc for static
site generation. That lead me to pick PAndoc as a rendering engine for
my Newt<a
href="Using%20Pandoc%20for%20the%20render%20engine%20could%20change%20in%20the%20future%20as%20long%20as%20a%20common%20way%20to%20package%20the%20results%20from%20template,%20options%20and%20data%20source%20response%20is%20as%20simple%20as%20it%20is%20with%20Pandoc%20server.">4</a>
prototype. If another template language and engine comes on the scene,
Newt can be adapted to us it instead<a
href="The%20group%20behind%20PostgREST%20is%20also%20developing%20an%20Postgres%20embedable%20Mustache%20engine,%20that%20may%20make%20sense%20too.">5</a>.
If you really don’t like Pandoc templates Newt now provides a similar
engine that supports Mustache templates, <code>newtmustache</code>.</p>
<p>The third question, “Why YAML for configuration?”. Personally I’m
enthusiastic about YAML. It is sort of boring. But I think that is is
strength. YAML has become umbiquious for describing configuration and
simple data structures. It easily converts to JSON. It’s declarative.
Newt uses YAML largely because it’s well known and is specifically known
by my colleagues at Caltech Library. Why invent a new language when I
can use one that is already known?</p>
<p>Final question is “How do I handle file uploads?”. The short answer
is Newt doesn’t. Eventually I plan to support for S3 protocol storage
systems (e.g. Minio, S3) but I haven’t had time to implement this and do
not need it for the application I am building with Newt. A longer answer
is yes, it is possible but you need to know Postgres really well.
Technically Postgres+PostgreSQL can handle file uploads because you can
store files or large objects in Postgres. Personally I don’t want to
store files in my data base management system. I’d rather store them in
an object store like S3. I don’t recomment Newt for applications that
require handling file uploads unless you want to write your own micro
service to implement it.</p>
<p>Newt’s configuration langauge is YAML. YAML was picked because it is
widely use in 2023/2024. I don’t need to explain it to my colleagues or
peers they already use it. Newt implements a “domain specific language”
or DSL on top of YAML to support rendering SQL data models targetting
Postgres. YAML is also an easy language to use to describe the
information needed for data routing in Newt. YAML seemed a good fit for
Newt.</p>
<h3 id="newts-minimal-feature-set">Newt’s minimal feature set</h3>
<ul>
<li><code>newt</code> as a two stage data router</li>
<li><code>newt</code> as static file service</li>
<li><code>newtpg</code> can use the Newt configuration file to render
simple data models as SQL generator suitable to bootstrap a
PostgREST+Postgres JSON API</li>
<li><code>newtform</code> can use the Newt configuration file to render
simple HTML/Markdown forms</li>
</ul>
<p>Here’s the data flow steps of <code>newt</code> data router.</p>
<ol type="1">
<li>Web browser =&gt; (Web Server proxy) =&gt; Newt</li>
<li>Newt =&gt; data source (e.g. Postgres + PostgREST or S3 Object
store)</li>
<li>Newt =&gt; Pandoc (optional step)</li>
<li>Newt =&gt; (Web Server proxy) =&gt; Web browser</li>
</ol>
<p>The person developing with Newt writes SQL to define the back end,
may write Pandoc templates if that is desired and builds the front end
with standard static web assets (e.g. HTML pages, CSS, JavaScript). Newt
can support traditional websites and single page applications. It just
saves writing a whole bunch of services that already exist.</p>
<h2 id="orchestrating-your-app-with-newt">Orchestrating your app with
Newt</h2>
<p>Newt is configured with a YAML file. Currently the configuration file
uses five main attributes and a collection of sub attributes.</p>
<dl>
<dt>htdocs</dt>
<dd>
The path to the htdocs directory holding any static assets (e.g. CSS,
JavaScript, HTML files, image assets)
</dd>
<dt>env</dt>
<dd>
A list of environment variables available to Newt’s routes and models
(this is how Newt avoids storing secrets)
</dd>
<dt>routes</dt>
<dd>
An object describing the mapping of an HTTP request to JSON data source
and and optional Pandoc server processing
</dd>
<dt>namespace</dt>
<dd>
This is the schema name used to interact with PostgREST+Postgres
</dd>
<dt>models</dt>
<dd>
This is a list of data models used by Newt to generate bootstrap SQL
code for PostgREST+Postgres. The markup will be models is based on
GitHub YAML issues template syntax.
</dd>
</dl>
<p>The <strong>htdocs</strong> just points at a standard directory
holding your static web content. It has no sub attributes.</p>
<p>The <strong>env</strong> attributes holds a list of environment
variable names that can be used by Newt when defining
<strong>routes</strong>.</p>
<p>Under <strong>routes</strong> you will also use the following
attributes</p>
<dl>
<dt>var</dt>
<dd>
(optional) A list of variable names and types used in validating a
request path or web from submission
</dd>
<dt>req_path</dt>
<dd>
A expression describing a URL path received by Newt (typical made by a
web browser or proxied from the front end web server)
</dd>
<dt>req_method</dt>
<dd>
An HTTP method (e.g. GET, POST, PUT, PATCH, DELETE) related to the
req_path being handled
</dd>
<dt>api_url</dt>
<dd>
The URL expression used by Newt to contact the JSON data source for the
route described by req_path and req_method. Newt can communicate using
one of two protocols identified in the URL, <code>http://</code> or
<code>s3://</code>.
</dd>
<dt>api_method</dt>
<dd>
The HTTP method (e.g. GET, POST, PUT, PATCH, DELETE) of the JSON data
source associated api_url for the given route
</dd>
<dt>api_content_type</dt>
<dd>
The HTTP content type expression used when submitting the request to the
JSON data source
</dd>
<dt>template</dt>
<dd>
(optional) The path to the pandoc or mustache template used to process
the results of the JSON data source request results
</dd>
<dt>render_port</dt>
<dd>
(optional) Set the port to use for contacting the render engine. If not
set it assume 3030 is the port for the render engine.
</dd>
</dl>
<p>The <strong>models</strong> attribute holds a list of models
expressed in Newt’s data model DSL. The original protype DSL is going to
be replaced with the YAML described in <a
href="https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/syntax-for-issue-forms">Syntax
for Github’s form schema</a>. That syntax will allow the creation of
<code>newtform</code> to generate web forms as well as be used by
<code>newtpg</code> to generate Postgres compatible SQL models and
behaviors. Here is an example using the old syntax as a placeholder.</p>
<h3 id="handling-errors">Handling errors</h3>
<p>Newt command vets the initial request before contacting the JSON data
source. If the request has a problem it will return an appropriate HTTP
status code and message. If the request to the JSON data source has a
problem, it will pass through the HTTP status code and message provided
by the JSON data source. Likewise if Pandoc server has a problem Newt
will forward that HTTP status code and message. If either the JSON data
source or Pandoc server is unavailable Newt will return a “Gateway” http
status code and message.</p>
<h3 id="static-file-support">Static file support</h3>
<p>Newt command first checks if a request is matched in one of the
defined routes. If not it’ll try to service the content from the
“htdocs” location if that is defined in the configuration. If the file
is not found or an htdocs directory has not been specified a http status
of 404 is returned.</p>
<p>Note Newt’s static file services are very basic. You can’t configure
mime type responses or modify behavior via “htaccess” files. If Newt is
running behind a traditional web server like Apache 2 or NginX then you
could use that service to host your static content providing additional
flexibilty.</p>
<h3 id="handling-secrets-scaling-and-limitations">Handling secrets,
scaling and limitations</h3>
<p>Newt’s YAML file does not explicitly contain any secrets. This was
intentional. You may need to pass sensitive data to your JSON data
source for access (e.g. credentials like a username and password). This
should be provided via the environment and the YAML file needs to
include these environment variable names in the “env” attribute. The
environment variables can be used to construct the URLs to contact the
JSON or S3 data sources. There is still a risk in that theoretically
that data source could echo return sensitive information. Newt can’t
prevent that. Newt is naive in its knowledge of the data source content
it receives or hands off to Pandoc. You’re responsible for securing
sensitive information at the database or s3 data source level. Follow
the recommendations in the Postgres community around securing
Postgres.</p>
<p>While Newt was conceived to be used on as a small scale web
application platform for libraries, archives and museums it is capable
of scaling big as long as your data source(s) can scale big. Using the
initial “Newt stack” elements can all be run easily behind load
balancers and in parallel across machines. Newt is transactional. It
does not require synchronized or shared of data between instances.
Similarly PostgREST and Pandoc services are transactional and do not
require shared state to function in parallel. Postgres itself can be
configured in a HA cluster to support high availability and high demand.
It should be possible to scale a Newt based application as large as
those systems can be scaled.</p>
<p>Presently Newt does not supports file uploads. The plan is to
integrated support for an S3 object store. That support is still very
much in the planning stages.</p>
<p>Newt command runs exclusively as a localhost service. In a production
setting you’d run Newt behind a traditional web server like Apache 2 or
NginX. The front end web service can provide access control via basic
auth or single sign-on (e.g. Shibboleth). Newt plays nicely in a
container environment, running as a system service or invoked from the
command line.</p>
<p>Postgres is available from <a href="https://postgres.org"
class="uri">https://postgres.org</a>.</p>
<h2 id="about-the-newt-source-repository">About the Newt source
repository</h2>
<p>Newt is a project of Caltech Library’s Digital Library Development
group. It is hosted on GitHub at <a
href="https://github.com/caltechlibrary/newt"
class="uri">https://github.com/caltechlibrary/newt</a>. If you have
questions, problems or concerns regarding Newt you can use GitHub issue
tracker to communicate with the development team. It is located at <a
href="https://github.com/caltechlibrary/newt/issues"
class="uri">https://github.com/caltechlibrary/newt/issues</a>.</p>
<h3 id="someday-maybe-ideas-to-explore">“Someday, maybe” ideas to
explore</h3>
<ul>
<li>Integrate S3 object store support as a data source</li>
<li>Support other rendering engines besides Pandoc server</li>
</ul>
<h2 id="documentation">Documentation</h2>
<ul>
<li><a href="INSTALL.html">INSTALL</a></li>
<li><a href="user-manual.html">user manual</a></li>
<li><a href="about.html">About</a></li>
</ul>
</section>

<footer>
<span><h1><A href="http://caltech.edu">Caltech</a></h1></span>
<span>&copy; 2023 <a href="https://www.library.caltech.edu/copyright">Caltech library</a></span>
<address>1200 E California Blvd, Mail Code 1-32, Pasadena, CA 91125-3200</address> 
<span>Phone: <a href="tel:+1-626-395-3405">(626)395-3405</a></span>
<span><a href="mailto:library@caltech.edu">Email Us</a></span>
<a class="cl-hide" href="sitemap.xml">Site Map</a>
</footer>
</body>
</html>
