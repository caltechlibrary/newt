
# Newt, a page assembler micro service

An idea occurred to me about PostgreSQL and PostgREST. It is missing feature the ability to render a web page. It lacks access to a template engine. Pandoc Server seems ripe for this. What is needed is a micro service that takes a requested URL, fetches the data and template from PostgREST hands it to Pandoc server before returning the assembled page to the requestor (e.g. web browser or front end web server).

The question is one of routing. Which request is sent to PostgREST and which template is used to send to Pandoc server. This reduces the problem to a function of routing. Where is the mapping defined and managed? I think the route handler could defined in PostgreSQL via a PL. The URL Path, HTTP Method and any payload is sent to PostgREST triggering the route handler. The route handler function processes the routing hand back the HTTP status code, message, headers and any Obecjts and Pandoc template name. The is then bounced to Pandoc server before handling the results back to the requestor.

How do we deal with file uploads?

~~~
Web Browser (GET) -> page assembler -> PostgREST (PL GET router function ) -> page assembler \
    -+ (no error) -> Pandoc Server -> page assembler -> Web browser
     |
     + (error, permissions issue) http status code for error/page -> Web Browser
~~~

## Refining the ideas

If the PL function could talk directly to the web server we could pass the assembled page back directly from PostgREST passing it onto the web browser.

This would require knowledge of SQL, PL, Pandoc templates only. Need to think through form submission use case. Page assembler may naed to route GET and POST (and other supported HTtP Methods) independtly or to different PL router functios via PostgRES. Seems like a good use case for a simple Haskell program.

Configuration would be a simple of HTTP Method to PL function end point, Permission isues would be pushed back into PostgREST and PostgreSQL. Only need to support methods that are supported by PostgREST. Front end web server would handle rendering error pages.

PL function examples could be provided in Python, SQL and pgplSQL.

The PL functions access could be supplied controlled via Schma and Roles. You might be able to control this down to the row level for private versus public records loke those found in institutional repositories.


page_assembler
:  a micro service (middleware) that accepts a URL, parses its path and queries PostgREST for object(s) and template, sends  to pandoc server returning result to requestor. Route handler is defined in Postgres via a function. Function can apply permissions if nessary.  The function accepts a path and returns markup, content-type, suggested http status code/message. page_assembler passes that back to reqestor.


Logic in page assembler is minimal, Just url parse for a path to query PostgREST to get be results of route handler PL function in PostgreSQL. Objects can then be retrieved and routed along with the template to Pandoc server for final page content or if error return a http status code and error message.

PL function must accept a path and return the data object, template name, content type, suggested http status code and error msg if error. PL function is responsible for applying permissions.
.